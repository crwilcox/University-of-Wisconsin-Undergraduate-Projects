"nop", "No operation"

"add   $dest,$left,$right", "Addition with overflow : set $dest to ($left plus $right)"
"sub   $dest,$left,$right", "Subtraction with overflow : set $dest to ($left minus $right)"
"addi  $dest,$left,<signed>", "Addition immediate with overflow : set $dest to ($left plus signed 16-bit immediate)"
"addu  $dest,$left,$right", "Addition unsigned without overflow : set $dest to ($left plus $right), no overflow"
"subu  $dest,$left,$right", "Subtraction unsigned without overflow : set $dest to ($left minus $right), no overflow"
"addiu $dest,$left,<signed>", "Addition immediate unsigned without overflow : set $dest to ($left plus signed 16-bit immediate), no overflow"
"mult  $dest,$left", "Multiplication : Set hi to high-order 32 bits, lo to low-order 32 bits of the product of $dest and $left (use mfhi to access hi, mflo to access lo)"
"multu $dest,$left", "Multiplication unsigned : Set HI to high-order 32 bits, LO to low-order 32 bits of the product of unsigned $dest and $left (use mfhi to access HI, mflo to access LO)"
"mul   $dest,$left,$right", "Multiplication without overflow  : Set HI to high-order 32 bits, LO and $dest to low-order 32 bits of the product of $dest and $left (use mfhi to access HI, mflo to access LO)"
"madd  $dest,$left", "Multiply add : Multiply $dest by $left then increment HI by high-order 32 bits of product, increment LO by low-order 32 bits of product (use mfhi to access HI, mflo to access LO)"
"maddu $dest,$left", "Multiply add unsigned : Multiply $dest by $left then increment HI by high-order 32 bits of product, increment LO by low-order 32 bits of product, unsigned (use mfhi to access HI, mflo to access LO)"
"msub  $dest,$left", "Multiply subtract : Multiply $dest by $left then decrement HI by high-order 32 bits of product, decrement LO by low-order 32 bits of product (use mfhi to access HI, mflo to access LO)"
"msubu $dest,$left", "Multiply subtract unsigned : Multiply $dest by $left then decrement HI by high-order 32 bits of product, decement LO by low-order 32 bits of product, unsigned (use mfhi to access HI, mflo to access LO)"
"div   $dest,$left", "Division with overflow : Divide $dest by $left then set LO to quotient and HI to remainder (use mfhi to access HI, mflo to access LO)"
"divu  $dest,$left", "Division unsigned without overflow : Divide unsigned $dest by $left then set LO to quotient and HI to remainder (use mfhi to access HI, mflo to access LO)"

"mfhi $dest",  "Move from HI register : Set $dest to contents of HI (see multiply and divide operations)"
"mflo $dest",  "Move from LO register : Set $dest to contents of LO (see multiply and divide operations)"
"mthi $dest",  "Move to HI registerr : Set HI to contents of $dest (see multiply and divide operations)"
"mtlo $dest",  "Move to LO register : Set LO to contents of $dest (see multiply and divide operations)"
"and  $dest,$left,$right", "Bitwise AND : Set $dest to bitwise AND of $left and $right"
"or   $dest,$left,$right", "Bitwise OR : Set $dest to bitwise OR of $left and $right"
"andi $dest,$left,<unsigned>", "Bitwise AND immediate : Set $dest to bitwise AND of $left and zero-extended 16-bit immediate"
"ori  $dest,$left,<unsigned>", "Bitwise OR immediate : Set $dest to bitwise OR of $left and zero-extended 16-bit immediate"
"nor  $dest,$left,$right", "Bitwise NOR : Set $dest to bitwise NOR of $left and $right"
"xor  $dest,$left,$right", "Bitwise XOR (exclusive OR) : Set $dest to bitwise XOR of $left and $right"
"xori $dest,$left,<unsigned>", "Bitwise XOR immediate : Set $dest to bitwise XOR of $left and zero-extended 16-bit immediate"
"sll  $dest,$left,<numbits>", "Shift left logical : Set $dest to result of shifting $left left by number of bits specified by immediate"
"sllv $dest,$left,$right", "Shift left logical variable : Set $dest to result of shifting $left left by number of bits specified by value in low-order 5 bits of $right"
"srl  $dest,$left,<numbits>", "Shift right logical : Set $dest to result of shifting $left right by number of bits specified by immediate"
"sra  $dest,$left,<numbits>", "Shift right arithmetic : Set $dest to result of sign-extended shifting $left right by number of bits specified by immediate"
"srav $dest,$left,$right", "Shift right arithmetic variable : Set $dest to result of sign-extended shifting $left right by number of bits specified by value in low-order 5 bits of $right"
"srlv $dest,$left,$right", "Shift right logical variable : Set $dest to result of shifting $left right by number of bits specified by value in low-order 5 bits of $right"
"lui  $dest,<unsigned>", "Load upper immediate : Set high-order 16 bits of $dest to 16-bit immediate and low-order 16 bits to 0"

"lw $dest,<offset>($base)", "Load word : Set $dest to contents of effective memory word address"
"ll $dest,<offset>($base)", "Load linked : Paired with Store Conditional (sc) to perform atomic read-modify-write.  Treated as equivalent to Load Word (lw) because MARS does not simulate multiple processors."
"lwl $dest,<offset>($base)", "Load word left : Load from 1 to 4 bytes left-justified into $dest, starting with effective memory byte address and continuing through the low-order byte of its word"
"lwr $dest,<offset>($base)", "Load word right : Load from 1 to 4 bytes right-justified into $dest, starting with effective memory byte address and continuing through the high-order byte of its word"
"sw $src,<offset>($base)", "Store word : Store contents of $src into effective memory word address"
"sc $src,<offset>($base)", "Store conditional : Paired with Load Linked (ll) to perform atomic read-modify-write.  Stores $src value into effective address, then sets $src to 1 for success.  Always succeeds because MARS does not simulate multiple processors."
"swl $src,<offset>($base)", "Store word left : Store high-order 1 to 4 bytes of $src into memory, starting with effective byte address and continuing through the low-order byte of its word"
"swr $src,<offset>($base)", "Store word right : Store low-order 1 to 4 bytes of $src into memory, starting with high-order byte of word containing effective byte address and continuing through that byte address"
"lb  $dest,<offset>($base)", "Load byte : Set $dest to sign-extended 8-bit value from effective memory byte address"
"lh  $dest,<offset>($base)", "Load halfword : Set $dest to sign-extended 16-bit value from effective memory halfword address"
"lhu $dest,<offset>($base)", "Load halfword unsigned : Set $dest to zero-extended 16-bit value from effective memory halfword address"
"lbu $dest,<offset>($base)", "Load byte unsigned : Set $dest to zero-extended 8-bit value from effective memory byte address"
"sb  $src,<offset>($base)", "Store byte : Store the low-order 8 bits of $src into the effective memory byte address"
"sh  $src,<offset>($base)", "Store halfword : Store the low-order 16 bits of $src into the effective memory halfword address"


"beq    $left,$t2,<label>", "Branch if equal : Branch to statement at <label>'s address if $left and $t2 are equal"
"bne    $left,$t2,<label>", "Branch if not equal : Branch to statement at <label>'s address if $left and $t2 are not equal"
"bgez   $src,<label>", "Branch if greater than or equal to zero : Branch to statement at <label>'s address if $src is greater than or equal to zero"
"bgezal $src,<label>", "Branch if greater then or equal to zero and link : If $src is greater than or equal to zero, then set $ra to the Program Counter and branch to statement at <label>'s address"
"bgtz   $src,<label>", "Branch if greater than zero : Branch to statement at <label>'s address if $src is greater than zero"
"blez   $src,<label>", "Branch if less than or equal to zero : Branch to statement at <label>'s address if $src is less than or equal to zero"
"bltz   $src,<label>", "Branch if less than zero : Branch to statement at <label>'s address if $src is less than zero"
"bltzal $src,<label>", "Branch if less than zero and link : If $src is less than or equal to zero, then set $ra to the Program Counter and branch to statement at <label>'s address"
"slt    $dest,$t2,$t3", "Set less than : If $t2 is less than $t3, then set $dest to 1 else set $dest to 0"
"sltu   $dest,$t2,$t3", "Set less than unsigned : If $t2 is less than $t3 using unsigned comparision, then set $dest to 1 else set $dest to 0"
"slti   $dest,$t2,<signed>", "Set less than immediate : If $t2 is less than sign-extended 16-bit immediate, then set $dest to 1 else set $dest to 0"
"sltiu   $dest,$t2,<signed>", "Set less than immediate unsigned : If $t2 is less than  sign-extended 16-bit immediate using unsigned comparison, then set $dest to 1 else set $dest to 0"
"movn $dest,$t2,$t3", "Move conditional not zero : Set $dest to $t2 if $t3 is not zero"
"movz $dest,$t2,$t3", "Move conditional zero : Set $dest to $t2 if $t3 is zero"
"movf $dest,$t2", "Move if FP condition flag 0 false : Set $dest to $t2 if FPU (Coprocessor 1) condition flag 0 is false (zero)"
"movf $dest,$t2,1", "Move if specified FP condition flag false : Set $dest to $t2 if FPU (Coprocessor 1) condition flag specified by the immediate is false (zero)"
"movt $dest,$t2", "Move if FP condition flag 0 true : Set $dest to $t2 if FPU (Coprocessor 1) condition flag 0 is true (one)"
"movt $dest,$t2,1", "Move if specfied FP condition flag true : Set $dest to $t2 if FPU (Coprocessor 1) condition flag specified by the immediate is true (one)"

"break <unsigned>",  "Break execution with code : Terminate program execution with specified exception code"
"break",  "Break execution : Terminate program execution with exception"
"syscall",  "Issue a system call : Execute the system call specified by value in $v0"

"j  <label>",  "Jump unconditionally : Jump to statement at <label> address"
"jr $src",  "Jump register unconditionally : Jump to statement whose address is in $src"
"jal <label>", "Jump and link : Set $ra to Program Counter (return address) then jump to statement at <label> address"
"jalr $dest,$src", "Jump and link register : Set $dest to Program Counter (return address) then jump to statement whose address is in $src"
"jalr $src", "Jump and link register : Set $ra to Program Counter (return address) then jump to statement whose address is in $src"

"clo $dest,$src",  "Count number of leading ones : Set $dest to the count of leading one bits in $src starting at most significant bit position"
"clz $dest,$src",  "Count number of leading zeroes : Set $dest to the count of leading zero bits in $src starting at most significant bit positio"

#"mfc0 $dest,$8",  "Move from Coprocessor 0 : Set $dest to the value stored in Coprocessor 0 register $8"
#"mtc0 $t1,$8",  "Move to Coprocessor 0 : Set Coprocessor 0 register $8 to value stored in $t1"

"add.s     $fpdest,$fpleft,$fpright", "Floating point addition single precision : Set $fpdest to single-precision floating point value of $fpleft plus $fpright",
"sub.s     $fpdest,$fpleft,$fpright", "Floating point subtraction single precision : Set $fpdest to single-precision floating point value of $fpleft  minus $fpright"
"mul.s     $fpdest,$fpleft,$fpright", "Floating point multiplication single precision : Set $fpdest to single-precision floating point value of $fpleft times $fpright"
"div.s     $fpdest,$fpleft,$fpright", "Floating point division single precision : Set $fpdest to single-precision floating point value of $fpleft divided by $fpright"
"sqrt.s    $fpdest,$fpsrc", "Square root single precision : Set $fpdest to single-precision floating point square root of $fpsrc"
"floor.w.s $fpdest,$fpsrc", "Floor single precision to word : Set $fpdest to 32-bit integer floor of single-precision float in $fpsrc"
"ceil.w.s  $fpdest,$fpsrc", "Ceiling single precision to word : Set $fpdest to 32-bit integer ceiling of single-precision float in $fpsrc"
"round.w.s $fpdest,$fpsrc", "Round single precision to word : Set $fpdest to 32-bit integer round of single-precision float in $fpsrc"
"trunc.w.s $fpdest,$fpsrc", "Truncate single precision to word : Set $fpdest to 32-bit integer truncation of single-precision float in $fpsrc"
"add.d     $fpdest,$fpleft,$fpright", "Floating point addition double precision : Set $fpdest to double-precision floating point value of $fpleft plus $fpright"
"sub.d     $fpdest,$fpleft,$fpright", "Floating point subtraction double precision : Set $fpdest to double-precision floating point value of $fpleft minus $fpright"
"mul.d     $fpdest,$fpleft,$fpright", "Floating point multiplication double precision : Set $fpdest to double-precision floating point value of $fpleft times $fpright"
"div.d     $fpdest,$fpleft,$fpright", "Floating point division double precision : Set $fpdest to double-precision floating point value of $fpleft divided by $fpright"
"sqrt.d    $fpdest,$fpsrc", "Square root double precision : Set $fpdest to double-precision floating point square root of $fpsrc"
"ceil.w.d  $fpdest,$fpsrc", "Ceiling double precision to word : Set $fpdest to 32-bit integer ceiling of double-precision float in $fpsrc"
"round.w.d $fpdest,$fpsrc", "Round double precision to word : Set $fpdest to 32-bit integer round of double-precision float in $fpsrc"
"trunc.w.d $fpdest,$fpsrc", "Truncate double precision to word : Set $fpdest to 32-bit integer truncation of double-precision float in $fpsrc"

"bc1t <label>", "Branch if FP condition flag 0 true (BC1T, not BCLT) : If Coprocessor 1 condition flag 0 is true (one) then branch to statement at <label>'s address"
#"bc1t 1,<label>", "Branch if specified FP condition flag true (BC1T, not BCLT) : If Coprocessor 1 condition flag specified by immediate is true (one) then branch to statement at <label>'s address"
"bc1f <label>", "Branch if FP condition flag 0 false (BC1F, not BCLF) : If Coprocessor 1 condition flag 0 is false (zero) then branch to statement at <label>'s address"
#"bc1f 1,<label>", "Branch if specified FP condition flag false (BC1F, not BCLF) : If Coprocessor 1 condition flag specified by immediate is false (zero) then branch to statement at <label>'s address"

#"c.eq.s 1,$fpleft,$fpright", "Compare equal single precision : If $fpleft is equal to $fpright, set Coprocessor 1 condition flag specied by immediate to true else set it to false"
#"c.le.s 1,$fpleft,$fpright", "Compare less or equal single precision : If $fpleft is less than or equal to $fpright, set Coprocessor 1 condition flag specified by immediate to true else set it to false"
#"c.lt.s 1,$fpleft,$fpright", "Compare less than single precision : If $fpleft is less than $fpright, set Coprocessor 1 condition flag specified by immediate to true else set it to false"
#"c.eq.d 1,$fpleft,$fpright", "Compare equal double precision : If $fpleft is equal to $fpright (double-precision), set Coprocessor 1 condition flag specified by immediate to true else set it to false"
#"c.le.d 1,$fpleft,$fpright", "Compare less or equal double precision : If $fpleft is less than or equal to $fpright (double-precision), set Coprocessor 1 condition flag specfied by immediate true else set it false"
#"c.lt.d 1,$fpleft,$fpright", "Compare less than double precision : If $fpleft is less than $fpright (double-precision), set Coprocessor 1 condition flag specified by immediate to true else set it to false"

"c.eq.s $fpleft,$fpright",   "Compare equal single precision : If $fpleft is equal to $fpright, set Coprocessor 1 condition flag 0 true else set it false"
"c.le.s $fpleft,$fpright",   "Compare less or equal single precision : If $fpleft is less than or equal to $fpright, set Coprocessor 1 condition flag 0 true else set it false"
"c.lt.s $fpleft,$fpright",   "Compare less than single precision : If $fpleft is less than $fpright, set Coprocessor 1 condition flag 0 true else set it false"
"c.eq.d $fpleft,$fpright",   "Compare equal double precision : If $fpleft is equal to $fpright (double-precision), set Coprocessor 1 condition flag 0 true else set it false"
"c.le.d $fpleft,$fpright",   "Compare less or equal double precision : If $fpleft is less than or equal to $fpright (double-precision), set Coprocessor 1 condition flag 0 true else set it false"
"c.lt.d $fpleft,$fpright",   "Compare less than double precision : If $fpleft is less than $fpright (double-precision), set Coprocessor 1 condition flag 0 true else set it false"

"abs.s   $fpdest,$fpsrc", "Floating point absolute value single precision : Set $fpdest to absolute value of $fpsrc, single precision"
"abs.d   $fpdest,$fpsrc", "Floating point absolute value double precision : Set $fpdest to absolute value of $fpsrc, double precision"
"cvt.d.s $fpdest,$fpsrc", "Convert from single precision to double precision : Set $fpdest to double precision equivalent of single precision value in $fpsrc"
"cvt.d.w $fpdest,$fpsrc", "Convert from word to double precision : Set $fpdest to double precision equivalent of 32-bit integer value in $fpsrc"
"cvt.s.d $fpdest,$fpsrc",        "Convert from double precision to single precision : Set $fpdest to single precision equivalent of double precision value in $fpsrc"
"cvt.s.w $fpdest,$fpsrc", "Convert from word to single precision : Set $fpdest to single precision equivalent of 32-bit integer value in $fpsrc"
"cvt.w.d $fpdest,$fpsrc",        "Convert from double precision to word : Set $fpdest to 32-bit integer equivalent of double precision value in $fpsrc"
"cvt.w.s $fpdest,$fpsrc", "Convert from single precision to word : Set $fpdest to 32-bit integer equivalent of single precision value in $fpsrc"
"mov.d  $fpdest,$fpsrc",  "Move floating point double precision : Set double precision $fpdest to double precision value in $fpsrc"
"movf.d $fpdest,$fpsrc",  "Move floating point double precision : If condition flag 0 false, set double precision $fpdest to double precision value in $fpsrc"
"movf.d $fpdest,$fpsrc,1",   "Move floating point double precision : If condition flag specified by immediate is false, set double precision $fpdest to double precision value in $fpsrc"
"movt.d $fpdest,$fpsrc",     "Move floating point double precision : If condition flag 0 true, set double precision $fpdest to double precision value in $fpsrc"
"movt.d $fpdest,$fpsrc,1",   "Move floating point double precision : If condition flag specified by immediate is true, set double precision $fpdest to double precision value in $fpsrce"
"movn.d $fpdest,$fpsrc,$intreg", "Move floating point double precision : If $intreg is not zero, set double precision $fpdest to double precision value in $fpsrc"
"movz.d $fpdest,$fpsrc,$intreg", "Move floating point double precision : If $intreg is zero, set double precision $fpdest to double precision value in $fpsrc"
"mov.s  $fpdest,$fpsrc",   "Move floating point single precision : Set single precision $fpdest to single precision value in $fpsrc"
"movf.s $fpdest,$fpsrc",   "Move floating point single precision : If condition flag 0 is false, set single precision $fpdest to single precision value in $fpsrc"
"movf.s $fpdest,$fpsrc,1", "Move floating point single precision : If condition flag specified by immediate is false, set single precision $fpdest to single precision value in $fpsrce"
"movt.s $fpdest,$fpsrc",   "Move floating point single precision : If condition flag 0 is true, set single precision $fpdest to single precision value in $fpsrce"
"movt.s $fpdest,$fpsrc,1", "Move floating point single precision : If condition flag specified by immediate is true, set single precision $fpdest to single precision value in $fpsrce"
"movn.s $fpdest,$fpsrc,$intreg", "Move floating point single precision : If $intreg is not zero, set single precision $fpdest to single precision value in $fpsrc"
"movz.s $fpdest,$fpsrc,$intreg", "Move floating point single precision : If $intreg is zero, set single precision $fpdest to single precision value in $fpsrc"

"mfc1  $intdest,$fpsrc", "Move from Coprocessor 1 (FPU) : Set $intdest to value in Coprocessor 1 register $fpsrc"
"mtc1  $intsrc,$fpdest", "Move to Coprocessor 1 (FPU) : Set Coprocessor 1 register $fpdest to value in $intsrc"

"neg.d $fpdest,$fpsrc", "Floating point negate double precision : Set double precision $fpdest to negation of double precision value in $fpsrc"
"neg.s $fpdest,$fpsrc", "Floating point negate single precision : Set single precision $fpdest to negation of single precision value in $fpsrc"

"lwc1 $fpdest,<offset>($base)", "Load word into Coprocessor 1 (FPU) : Set $fpdest to 32-bit value from effective memory word address"
"ldc1 $fpdest,<offset>($base)", "Load double word Coprocessor 1 (FPU)) : Set $fpdest to 64-bit value from effective memory doubleword address"
"swc1 $fpsrc,<offset>($base)", "Store word from Coprocesor 1 (FPU) : Store 32 bit value in $fpsrc to effective memory word address"
"sdc1 $fpsrc,<offset>($base)", "Store double word from Coprocessor 1 (FPU)) : Store 64 bit value in $fpsrc to effective memory doubleword address"

"teq  $left,$right", "Trap if equal : Trap if $left is equal to $right"
"teqi $src,<signed>", "Trap if equal to immediate : Trap if $src is equal to sign-extended 16 bit immediate"
"tne  $left,$right", "Trap if not equal : Trap if $left is not equal to $right"
"tnei $src,<signed>", "Trap if not equal to immediate : Trap if $src is not equal to sign-extended 16 bit immediate"
"tge  $left,$right", "Trap if greater or equal : Trap if $left is greater than or equal to $right"
"tgeu $left,$right", "Trap if greater or equal unsigned : Trap if $left is greater than or equal to $right using unsigned comparision"
"tgei $src,<signed>", "Trap if greater than or equal to immediate : Trap if $src greater than or equal to sign-extended 16 bit immediate"
"tgeiu $src,<signed>", "Trap if greater or equal to immediate unsigned : Trap if $src greater than or equal to sign-extended 16 bit immediate, unsigned comparison"
"tlt  $left,$right", "Trap if less than: Trap if $left less than $right"
"tltu $left,$right", "Trap if less than unsigned : Trap if $left less than $right, unsigned comparison"
"tlti $src,<signed>", "Trap if less than immediate : Trap if $src less than sign-extended 16-bit immediate"
"tltiu $src,<signed>", "Trap if less than immediate unsigned : Trap if $src less than sign-extended 16-bit immediate, unsigned comparison"

"eret",  "Exception return : Set Program Counter to Coprocessor 0 EPC register value, set Coprocessor Status register bit 1 (exception level) to zero"
